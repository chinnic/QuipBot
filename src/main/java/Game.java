import com.opencsv.CSVParser;
import com.opencsv.CSVParserBuilder;
import com.opencsv.CSVReader;
import com.opencsv.CSVReaderBuilder;
import net.dv8tion.jda.api.EmbedBuilder;
import net.dv8tion.jda.api.entities.MessageChannel;
import net.dv8tion.jda.api.entities.PrivateChannel;
import net.dv8tion.jda.api.entities.User;
import net.dv8tion.jda.api.requests.RestAction;

import java.awt.*;
import java.io.File;
import java.io.FileReader;
import java.util.*;
import java.util.List;

public class Game {
    private GameListener Main;
    private List<User> players;
    private MessageChannel channel;
    private String messageId;

    private boolean addingPlayers;
    private boolean isRecordingResponses;
    private boolean isRecordingPrompts;
    private boolean isGameFinished;

    private List<String> playerQuestionSave;
    private int roundsLeft;
    private List<String> cumulativeQuestions;

    //testing fields:

    private List<Player> gamePlayers;
    private List<String> questionList;
    private Map<Player, Integer> pointRecord;

    public Game(GameListener Main, String messageId, MessageChannel channel) {
        this.Main = Main;
        this.messageId = messageId;
        this.channel = channel;
        this.players = new ArrayList<>();
        this.addingPlayers = false;
        this.isRecordingResponses = false;
        this.isRecordingPrompts = false;
        this.isGameFinished = false;
        this.playerQuestionSave = new ArrayList<>();
        this.roundsLeft = 2;
        this.cumulativeQuestions = new ArrayList<>();

        this.gamePlayers = new ArrayList<>();
        this.questionList = new ArrayList<>();
        this.pointRecord = new HashMap<>();
    }

    public void phase0() {
        Timer startTimer = new Timer();

        channel.sendMessage("http://www.lilynow.com/wp-content/uploads/2020/12/newPrompts.png").queue();
        EmbedBuilder eb = new EmbedBuilder();
        eb.setTitle("**Phase 1: Check your private message from QuipBot!**");
        eb.setColor(new Color(214, 173, 37));
        eb.setDescription("You will have **20 seconds** to make one prompt and **40 seconds** to answer two prompts");
        channel.sendMessage(eb.build()).queue();

        for(int i = 0; i < this.players.size(); i++) {
            RestAction<PrivateChannel> restAction = this.players.get(i).openPrivateChannel();

            RestAction<PrivateChannel> restAction1 = this.gamePlayers.get(i).getUser().openPrivateChannel();

            EmbedBuilder eb1 = new EmbedBuilder();
            eb1.setTitle("Input your prompt below! Type `!qb random` for an autogenerated prompt!");
            eb1.setDescription("Reminder: You have **20 seconds** to make ***one*** prompt");
            eb1.setColor(new Color(214, 173, 37));

            Player tempPlayerReference = this.gamePlayers.get(i);
            restAction1.queue((channel1) -> {
                channel1.sendMessage("http://www.lilynow.com/wp-content/uploads/2020/12/newPrompts.png").queue();
                channel1.sendMessage(eb1.build()).queue();
                tempPlayerReference.setDmId(channel1.getId());
            });

            TimerTask reminderTask = new TimerTask() {
                @Override
                public void run() {
                    restAction.queue((channel1) -> channel1.sendMessage("**Times Up! Head back to the server for voting!**").queue());
                }
            };
            startTimer.schedule(reminderTask, 60000);
        }
        startTimer.schedule(new QuestionTimer(this), 20000);
        isRecordingPrompts = true;
    }

    public void phase1() {
        Timer startTimer = new Timer();
        Random random = new Random(System.currentTimeMillis());
        File generalPrompt = new File("/Users/jason/IdeaProjects/discord/src/main/GeneralPrompts.csv");
        List<String[]> prompts = readCSV(generalPrompt);

        for (Player player: gamePlayers) {
            if (player.getPrompt().equals("")) {
                player.setPrompt(prompts.get(random.nextInt(prompts.size()))[0]);
            }
            questionList.add(player.getPrompt());
        }

        for (int i = 0; i < this.gamePlayers.size(); i++) {
            RestAction<PrivateChannel> restAction = this.gamePlayers.get(i).getUser().openPrivateChannel();
            String prompt = questionList.get(this.gamePlayers.size() - i - 1);

            gamePlayers.get(i).addToFirstQuestion(prompt);
            if (i != gamePlayers.size() - 1) {
                gamePlayers.get(i + 1).addToSecondQuestion(prompt);
            } else {
                gamePlayers.get(0).addToSecondQuestion(prompt);
            }

            EmbedBuilder eb = new EmbedBuilder();
            eb.setTitle("**Here's your first question (1/2)**:");
            eb.setDescription(prompt);
            eb.setColor(new Color(214, 173, 37));

            restAction.queue((channel1) -> {
                channel1.sendMessage("http://www.lilynow.com/wp-content/uploads/2020/12/newResponses2.png").queue();
                channel1.sendMessage(eb.build()).queue();
            });
        }

        startTimer.schedule(new StartTimer(this, channel), 40000);
        isRecordingResponses = true;
    }

    public void phase2() {
        Timer startTimer = new Timer();

        for(Player player: this.gamePlayers) {
            if (player.getFirstQuestion().size() == 1) {
                player.addToFirstQuestion("rip, i ran out of time");
            }
            if (player.getSecondQuestion().size() == 1) {
                player.addToSecondQuestion("rip, i ran out of time");
            }
        }

        String transitionMessage = "";
        for (int i = 0; i < 55; i++) {
            transitionMessage += "\\_\\_";
        }
        channel.sendMessage(transitionMessage).queue();
        startTimer.schedule(new ShowTimer(this, channel, questionList), 100);
    }

    public void phase3() {
        Timer timer = new Timer();
        channel.sendFile(new File("/Users/jason/Pictures/scoreboard.png")).queue();

        List<Player> players = new ArrayList<>(pointRecord.keySet());
        List<List<Player>> scores1 = new ArrayList<>();
        for (int i = 0 ; i < players.size(); i++) {
            scores1.add(new ArrayList<>());
        }
        for (int i = 0; i < scores1.size(); i++) {
            int maxScore = 0;
            for (Player player: players) {
                if (pointRecord.get(player) > maxScore) {
                    scores1.get(i).clear();
                    scores1.get(i).add(player);
                    maxScore = pointRecord.get(player);
                } else if (pointRecord.get(player) == maxScore) {
                    scores1.get(i).add(player);
                }
            }
            for (Player player: scores1.get(i)) {
                players.remove(player);
            }
        }
        displayScoreboard(scores1);

        if (roundsLeft == 1) {
            channel.sendMessage("Type `!qb prompts` to get a list of prompts used this game. You have 30 seconds to do so.").queue();
            timer.schedule(new DeleteTimer(this.Main, this), 30000);
            this.isGameFinished = true;
        } else {
            channel.sendMessage("The next round will begin in 10 seconds!").queue();
            class RestartTimer extends TimerTask {
                private Game game;

                public RestartTimer(Game game) {
                    this.game = game;
                }

                @Override
                public void run() {
                    game.phase0();
                }
            }
            timer.schedule(new RestartTimer(this), 10000);
            this.roundsLeft -= 1;
            this.memoryclear();
        }
    }

    public List<String[]> readCSV(File file) {
        try {
            // Create an object of file reader
            // class with CSV file as a parameter.
            FileReader filereader = new FileReader(file);

            // create csvReader object and skip first Line
            CSVParser parser = new CSVParserBuilder().withSeparator('\n').withIgnoreQuotations(true).build();
            CSVReader csvReader = new CSVReaderBuilder(filereader).withCSVParser(parser)
                    .build();
            return csvReader.readAll();
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public void displayScoreboard(List<List<Player>> scores) {
        for (int i = 0; i < scores.size(); i++) {
            for (Player player: scores.get(i)) {
            }
        }

        String scoresPrint = "";

        for (int i = 0; i < scores.size(); i++) {
            if (scores.get(i).size() != 0) {
                if (roundsLeft == 1) {
                    if (i == 0) {
                        scoresPrint += "**WINNER(S)** :first_place: ";
                    } else if (i == 1) {
                        scoresPrint += "**RUNNERUP(S)** :second_place: ";
                    } else if (i == 2) {
                        scoresPrint += "**THIRD PLACE** :third_place: ";
                    }
                }
                for (Player player: scores.get(i)) {
                    scoresPrint += "__" + player.getUser().getName() + "__ ";
                }
                scoresPrint += ": **" + pointRecord.get(scores.get(i).get(0)) + "**\n";
            }
        }



        EmbedBuilder eb = new EmbedBuilder();
        eb.setTitle("And that's a wrap on this round **(" + (2 - this.roundsLeft + 1) + "/2)**! Let's see those scores :trophy:");
        // should be in order from most to least points
        eb.setDescription(scoresPrint);
        eb.setColor(new Color(62, 153, 173));
        channel.sendMessage(eb.build()).queue();
    }

    public void displaySavablePrompts() {
        for (String question: this.cumulativeQuestions) {
            channel.sendMessage(question).queue(
                    (message1) -> {
                        message1.addReaction("\u2B07").queue();
                        this.addQuestionsSaved(message1.getId());
                    }
            );
        }

    }

    public List<User> getPlayers() {
        return this.players;
    }

    public String getChannelId() {
        return this.channel.getId();
    }

    public String getMessageId() {
        return this.messageId;
    }

    public void addPlayer(User user) {
        players.add(user);
        Player player = new Player(user);
        player.setGame(this);
        gamePlayers.add(player);
    }

    public boolean isAdding() {
        return addingPlayers;
    }

    public void setAdding(boolean state) {
        this.addingPlayers = state;
    }

    public void setRecordingResponses(boolean state) {
        this.isRecordingResponses = state;
    }

    public boolean isRecordingResponses() {
        return this.isRecordingResponses;
    }

    public boolean isRecordingPrompts() {
        return this.isRecordingPrompts;
    }

    public void setRecordingPrompts(boolean state) {
        this.isRecordingPrompts = state;
    }

    public boolean isGameFinished() {
        return this.isGameFinished;
    }

    public boolean hasInputtedQuestion(String userId) {
        boolean hasInputted = false;
        for (Player players: gamePlayers) {
            if (players.getUser().getId().equals(userId)) {
                if (!players.getPrompt().equals("")) {
                    hasInputted = true;
                }
            }
        }
        return hasInputted;
    }

    public void addQuestionsSaved(String messageId) {
        this.playerQuestionSave.add(messageId);
    }

    public List<String> getQuestionsSave() {
        return this.playerQuestionSave;
    }

    public void memoryclear() {
        this.questionList = new ArrayList<>();
        for (Player player: gamePlayers) {
            player.clear();
        }
    }

    //test methods:

    public List<Player> getGamePlayers() {
        return this.gamePlayers;
    }

    public void addPoints(Player player, int points) {
        if (!this.pointRecord.keySet().contains(player)) {
            this.pointRecord.put(player, points);
        } else {
            this.pointRecord.put(player, this.pointRecord.get(player) + points);
        }
    }

    public void addCumulativeQuestions(String question) {
        this.cumulativeQuestions.add(question);
    }
}
