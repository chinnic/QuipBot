import com.opencsv.CSVParser;
import com.opencsv.CSVParserBuilder;
import com.opencsv.CSVReader;
import com.opencsv.CSVReaderBuilder;
import net.dv8tion.jda.api.EmbedBuilder;
import net.dv8tion.jda.api.entities.MessageChannel;
import net.dv8tion.jda.api.entities.PrivateChannel;
import net.dv8tion.jda.api.entities.User;
import net.dv8tion.jda.api.requests.RestAction;

import java.awt.*;
import java.io.File;
import java.io.FileReader;
import java.util.*;
import java.util.List;

public class Game {
    //General Game attributes
    private GameListener Main;
    private MessageChannel channel;
    private String messageId;
    private int roundsLeft;

    //Game Phase Logic
    private boolean addingPlayers;
    private boolean isRecordingResponses;
    private boolean isRecordingPrompts;
    private boolean isGameFinished;

    //Handles saving prompts
    private List<String> playerQuestionSave;
    private List<String> cumulativeQuestions;

    //Player based storage
    private List<Player> gamePlayers;
    private List<String> questionList;
    private Map<Player, Integer> pointRecord;

    //constructor of the "Game" class
    //takes in a GameListener, String, and MessageChannel
    public Game(GameListener Main, String messageId, MessageChannel channel) {
        this.Main = Main;
        this.messageId = messageId;
        this.channel = channel;
        this.addingPlayers = false;
        this.isRecordingResponses = false;
        this.isRecordingPrompts = false;
        this.isGameFinished = false;
        this.playerQuestionSave = new ArrayList<>();
        this.roundsLeft = 2;
        this.cumulativeQuestions = new ArrayList<>();
        this.gamePlayers = new ArrayList<>();
        this.questionList = new ArrayList<>();
        this.pointRecord = new HashMap<>();
    }

    //post: initates "phase 0" of the current game, prompting players to enter prompts
    public void phase0() {
        Timer startTimer = new Timer();

        channel.sendMessage("http://www.lilynow.com/wp-content/uploads/2020/12/newPrompts.png").queue();
        EmbedBuilder eb = new EmbedBuilder();
        eb.setTitle("**Phase 1: Check your private message from QuipBot!**");
        eb.setColor(new Color(214, 173, 37));
        eb.setDescription("You will have **20 seconds** to make one prompt and **40 seconds** to answer two prompts");
        channel.sendMessage(eb.build()).queue();

        for(int i = 0; i < this.gamePlayers.size(); i++) {
            RestAction<PrivateChannel> restAction = this.gamePlayers.get(i).getUser().openPrivateChannel();

            EmbedBuilder eb1 = new EmbedBuilder();
            eb1.setTitle("Input your prompt below! Type `!qb random` for an autogenerated prompt!");
            eb1.setDescription("Reminder: You have **20 seconds** to make ***one*** prompt");
            eb1.setColor(new Color(214, 173, 37));

            Player tempPlayerReference = this.gamePlayers.get(i);
            restAction.queue((channel1) -> {
                channel1.sendMessage("http://www.lilynow.com/wp-content/uploads/2020/12/newPrompts.png").queue();
                channel1.sendMessage(eb1.build()).queue();
                tempPlayerReference.setDmId(channel1.getId());
            });

            TimerTask reminderTask = new TimerTask() {
                @Override
                public void run() {
                    restAction.queue((channel1) -> channel1.sendMessage("**Times Up! Head back to the server for voting!**").queue());
                }
            };
            startTimer.schedule(reminderTask, 60000);
        }
        startTimer.schedule(new QuestionTimer(this), 2000);
        isRecordingPrompts = true;
    }

    //post: initiates "phase 1" of the current game, prompting players to respond to different prompts
    public void phase1() {
        Timer startTimer = new Timer();
        Random random = new Random(System.currentTimeMillis());
        File generalPrompt = new File("/Users/jason/IdeaProjects/discord/src/main/GeneralPrompts.csv");
        List<String[]> prompts = readCSV(generalPrompt);

        for (Player player: gamePlayers) {
            if (player.getPrompt().equals("")) {
                player.setPrompt(prompts.get(random.nextInt(prompts.size()))[0]);
            }
            questionList.add(player.getPrompt());
        }

        for (int i = 0; i < this.gamePlayers.size(); i++) {
            RestAction<PrivateChannel> restAction = this.gamePlayers.get(i).getUser().openPrivateChannel();
            String prompt = questionList.get(this.gamePlayers.size() - i - 1);

            gamePlayers.get(i).addToFirstQuestion(prompt);
            if (i != gamePlayers.size() - 1) {
                gamePlayers.get(i + 1).addToSecondQuestion(prompt);
            } else {
                gamePlayers.get(0).addToSecondQuestion(prompt);
            }

            EmbedBuilder eb = new EmbedBuilder();
            eb.setTitle("**Here's your first question (1/2)**:");
            eb.setDescription(prompt);
            eb.setColor(new Color(214, 173, 37));

            restAction.queue((channel1) -> {
                channel1.sendMessage("http://www.lilynow.com/wp-content/uploads/2020/12/newResponses2.png").queue();
                channel1.sendMessage(eb.build()).queue();
            });
        }

        startTimer.schedule(new StartTimer(this, channel), 4000);
        isRecordingResponses = true;
    }

    //post: initiates "phase 2" of the current game, beginning the voting round
    public void phase2() {
        Timer startTimer = new Timer();

        for(Player player: this.gamePlayers) {
            if (player.getFirstQuestion().size() == 1) {
                player.addToFirstQuestion("rip, i ran out of time");
            }
            if (player.getSecondQuestion().size() == 1) {
                player.addToSecondQuestion("rip, i ran out of time");
            }
        }

        String transitionMessage = "";
        for (int i = 0; i < 55; i++) {
            transitionMessage += "\\_\\_";
        }
        channel.sendMessage(transitionMessage).queue();
        startTimer.schedule(new ShowTimer(this, channel, questionList), 100);
    }

    //post: initiates "phase 3" of the current game, displaying the current scoreboard
    public void phase3() {
        Timer timer = new Timer();
        channel.sendFile(new File("/Users/jason/Pictures/scoreboard.png")).queue();

        List<Player> players = new ArrayList<>(pointRecord.keySet());
        List<List<Player>> scores1 = new ArrayList<>();
        for (int i = 0 ; i < players.size(); i++) {
            scores1.add(new ArrayList<>());
        }
        for (int i = 0; i < scores1.size(); i++) {
            int maxScore = 0;
            for (Player player: players) {
                if (pointRecord.get(player) > maxScore) {
                    scores1.get(i).clear();
                    scores1.get(i).add(player);
                    maxScore = pointRecord.get(player);
                } else if (pointRecord.get(player) == maxScore) {
                    scores1.get(i).add(player);
                }
            }
            for (Player player: scores1.get(i)) {
                players.remove(player);
            }
        }
        displayScoreboard(scores1);

        if (roundsLeft == 1) {
            channel.sendMessage("Type `!qb prompts` to get a list of prompts used this game. You have 30 seconds to do so.").queue();
            timer.schedule(new DeleteTimer(this.Main, this), 30000);
            this.isGameFinished = true;
        } else {
            channel.sendMessage("The next round will begin in 10 seconds!").queue();
            class RestartTimer extends TimerTask {
                private final Game game;

                public RestartTimer(Game game) {
                    this.game = game;
                }

                @Override
                public void run() {
                    game.phase0();
                }
            }
            timer.schedule(new RestartTimer(this), 10000);
            this.roundsLeft -= 1;
            this.memoryclear();
        }
    }

    //pre: takes in a File "file" that should be of CSV format
    //post: returns the contents of the file as a list
    public List<String[]> readCSV(File file) {
        try {
            FileReader filereader = new FileReader(file);

            CSVParser parser = new CSVParserBuilder().withSeparator('\n').withIgnoreQuotations(true).build();
            CSVReader csvReader = new CSVReaderBuilder(filereader).withCSVParser(parser)
                    .build();
            return csvReader.readAll();
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    //pre: a list of player scores
    //post: outputs a formatted embed that displays the scores
    public void displayScoreboard(List<List<Player>> scores) {
        String scoresPrint = "";
        for (int i = 0; i < scores.size(); i++) {
            if (scores.get(i).size() != 0) {
                if (roundsLeft == 1) {
                    if (i == 0) {
                        scoresPrint += "**WINNER(S)** :first_place: ";
                    } else if (i == 1) {
                        scoresPrint += "**RUNNERUP(S)** :second_place: ";
                    } else if (i == 2) {
                        scoresPrint += "**THIRD PLACE** :third_place: ";
                    }
                }
                for (Player player: scores.get(i)) {
                    scoresPrint += "__" + player.getUser().getName() + "__ ";
                }
                scoresPrint += ": **" + pointRecord.get(scores.get(i).get(0)) + "**\n";
            }
        }
        EmbedBuilder eb = new EmbedBuilder();
        eb.setTitle("And that's a wrap on this round **(" + (2 - this.roundsLeft + 1) + "/2)**! Let's see those scores :trophy:");
        // should be in order from most to least points
        eb.setDescription(scoresPrint);
        eb.setColor(new Color(62, 153, 173));
        channel.sendMessage(eb.build()).queue();
    }

    //post: displays all the prompts that were used in the game while marking each with a
    //downwards arrow emote
    public void displaySavablePrompts() {
        for (String question: this.cumulativeQuestions) {
            channel.sendMessage(question).queue(
                    (message1) -> {
                        message1.addReaction("\u2B07").queue();
                        this.addQuestionsSaved(message1.getId());
                    }
            );
        }

    }

    //post: returns the id of the channel
    public String getChannelId() {
        return this.channel.getId();
    }

    //post: returns the id of the game initiation message
    public String getMessageId() {
        return this.messageId;
    }

    //post: adds a new player into the game
    public void addPlayer(User user) {
        Player player = new Player(user);
        player.setGame(this);
        gamePlayers.add(player);
    }

    //post: returns whether or not the game is still accepting new players
    public boolean isAdding() {
        return addingPlayers;
    }

    //post: sets whether the game will be accepting new players or not
    public void setAdding(boolean state) {
        this.addingPlayers = state;
    }

    //post: returns whether or not the game is recording responses
    public boolean isRecordingResponses() {
        return this.isRecordingResponses;
    }

    //post: sets whether or not the game is recording responses
    public void setRecordingResponses(boolean state) {
        this.isRecordingResponses = state;
    }

    //post: returns whether or not the game is recording prompts
    public boolean isRecordingPrompts() {
        return this.isRecordingPrompts;
    }

    //post: sets whether the game is recording prompts or not
    public void setRecordingPrompts(boolean state) {
        this.isRecordingPrompts = state;
    }

    //post: returns true if the game is finished
    public boolean isGameFinished() {
        return this.isGameFinished;
    }

    //pre: userId in the form of a String
    //post: checks if the player has already inputted a prompt
    public boolean hasInputtedQuestion(String userId) {
        boolean hasInputted = false;
        for (Player players: gamePlayers) {
            if (players.getUser().getId().equals(userId)) {
                if (!players.getPrompt().equals("")) {
                    hasInputted = true;
                }
            }
        }
        return hasInputted;
    }

    //pre: messageId in the form of a String
    //post: adds the inputted messageId to a system which will eventually
    //allow players to vote on which questions to save
    public void addQuestionsSaved(String messageId) {
        this.playerQuestionSave.add(messageId);
    }

    //post: returns a list of messageId's
    public List<String> getQuestionsSave() {
        return this.playerQuestionSave;
    }

    //post: clears the information related to the current round
    public void memoryclear() {
        this.questionList = new ArrayList<>();
        for (Player player: gamePlayers) {
            player.clear();
        }
    }

    //post: returns a list of the current players
    public List<Player> getGamePlayers() {
        return this.gamePlayers;
    }

    //pre: a Player "player" and an int "points"
    //post: adds to the players point score "points" amount of points
    public void addPoints(Player player, int points) {
        if (!this.pointRecord.keySet().contains(player)) {
            this.pointRecord.put(player, points);
        } else {
            this.pointRecord.put(player, this.pointRecord.get(player) + points);
        }
    }

    //adds the inputted to a cumulative list
    public void addCumulativeQuestions(String question) {
        this.cumulativeQuestions.add(question);
    }
}
